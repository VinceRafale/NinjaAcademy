package com.efzgames.ninjaacademy.elements;

import com.efzgames.framework.gl.Animation;
import com.efzgames.framework.gl.SpriteBatcher;
import com.efzgames.framework.gl.Texture;
import com.efzgames.framework.gl.TextureRegion;
import com.efzgames.framework.impl.GLGame;
import com.efzgames.framework.math.Line;
import com.efzgames.framework.math.Vector2;
import com.efzgames.ninjaacademy.GameConstants;
import com.efzgames.ninjaacademy.screens.GameScreen;

public class LaunchedComponent extends AnimatedComponent {

	// / Angular velocity in radians per second.
	public float angularVelocity;
	// / Velocity in pixels per second.
	public Vector2 velocity;
	// / Acceleration in pixels per squared second.
	public Vector2 acceleration;
	// // The component's rotation in radians.
	public float rotation;

	private boolean isEventFired = false;

	public float notifyHeight;

	public EventHandler droppedPastHeight;
	
	private float boundingBoxInflation =0;
	
	public synchronized void setBoundingBoxInflation(float value){
		this.boundingBoxInflation = value;
	}
	

	public LaunchedComponent(GLGame glGame, GameScreen gameScreen,
			Texture texture, TextureRegion textureRegion) {
		super(glGame, gameScreen, texture, textureRegion);

	}
	
	public LaunchedComponent(GLGame glGame, GameScreen gameScreen,
			Animation animation) {
		super(glGame, gameScreen, animation);

	}
	
	@Override
    public synchronized Vector2 getBoundingBoxMin(){
		Vector2[] points = getCurrentBoundCornerPositions();
		float minX= Float.MAX_VALUE, minY = Float.MAX_VALUE;
		for(int i=0; i<4; i++){
			if(points[i].x < minX)
				minX = points[i].x;
			if(points[i].y < minY)
				minY = points[i].y;
		}
   	 	return new Vector2( minX , minY);
    }
    
    @Override
    public synchronized Vector2 getBoundingBoxMax(){
    	Vector2[] points = getCurrentBoundCornerPositions();
		float minX= Float.MIN_VALUE, minY = Float.MIN_VALUE;
		for(int i=0; i<4; i++){
			if(points[i].x < minX)
				minX = points[i].x;
			if(points[i].y < minY)
				minY = points[i].y;
		}
   	 	return new Vector2( minX , minY);
    }
    
    @Override
    public synchronized float getBoundingHeight(){
   	 return getBoundingBoxMax().y - getBoundingBoxMin().y;
    }
    
    @Override
    public synchronized float getBoundingWidth(){
    	return getBoundingBoxMax().x - getBoundingBoxMin().x;
    }

	@Override
	public synchronized void update(float deltaTime) {
		
		super.update(deltaTime);
		
		float elapsedSeconds = deltaTime;
		velocity = velocity.add(Vector2.mul(acceleration, elapsedSeconds));
		position = position.add(Vector2.mul(velocity, elapsedSeconds));

		// Check whether the event generated by falling past a certain point
		// needs to be fired.
		if (!isEventFired && position.y < notifyHeight && velocity.y < 0) {
			if (droppedPastHeight != null) {
				droppedPastHeight.onEvent(this);
			}

			isEventFired = true;
		}

		rotation += angularVelocity * elapsedSeconds;
	}

	@Override
	public synchronized void present(float deltaTime, SpriteBatcher batcher) {
		
		batcher.beginBatch(texture);
		animation.present(deltaTime, batcher, position, rotation, visualCenter);
		batcher.endBatch();
	}
	
	public synchronized void Launch(Vector2 initialPosition, Vector2 initialVelocity, Vector2 acceleration, 
            float angularVelocity)
    {
            Launch(initialPosition, initialVelocity, acceleration, 0, angularVelocity);
    }

	public synchronized void Launch(Vector2 initialPosition, Vector2 initialVelocity,
			Vector2 acceleration, float initialRotation, float angularVelocity) {
		position = new Vector2(initialPosition);
		velocity = new Vector2(initialVelocity);
		rotation =initialRotation;
		this.acceleration = new Vector2(acceleration);
		this.angularVelocity = angularVelocity;
		isEventFired = false;
	}
	
	  public synchronized Line[] getEdges()
      {
          Vector2[] corners = getCurrentBoundCornerPositions();

          Line[] result = new Line[4];
          result[0] = new Line(corners[3], corners[2]);
          result[1] = new Line(corners[2], corners[1]);
          result[2] = new Line(corners[1], corners[0]);
          result[3] = new Line(corners[0], corners[3]);

          return result;
      }
	  
	  protected synchronized Vector2[] getCurrentBoundCornerPositions()
      { 
       
          Vector2[] unrotatedCornersAroundCenter = new Vector2[]
          {
              new Vector2(-(super.getBoundingWidth() + boundingBoxInflation )/ 2, (super.getBoundingHeight()+ boundingBoxInflation )/ 2),
              new Vector2((super.getBoundingWidth() + boundingBoxInflation) / 2, (super.getBoundingHeight() + boundingBoxInflation) / 2),
              new Vector2((super.getBoundingWidth() + boundingBoxInflation) / 2, -(super.getBoundingHeight() + boundingBoxInflation) / 2),
              new Vector2(-(super.getBoundingWidth() + + boundingBoxInflation) / 2, -(super.getBoundingHeight() +  boundingBoxInflation) / 2)
          };

          // Rotate the corners around (0, 0)
          unrotatedCornersAroundCenter[0] = unrotatedCornersAroundCenter[0].rotate(rotation * Vector2.TO_DEGREES);
          unrotatedCornersAroundCenter[1] = unrotatedCornersAroundCenter[1].rotate(rotation * Vector2.TO_DEGREES);
          unrotatedCornersAroundCenter[2] = unrotatedCornersAroundCenter[2].rotate(rotation * Vector2.TO_DEGREES);
          unrotatedCornersAroundCenter[3] = unrotatedCornersAroundCenter[3].rotate(rotation * Vector2.TO_DEGREES);
                

          unrotatedCornersAroundCenter[0] = unrotatedCornersAroundCenter[0].add(position);
          unrotatedCornersAroundCenter[1] = unrotatedCornersAroundCenter[1].add(position);
          unrotatedCornersAroundCenter[2] = unrotatedCornersAroundCenter[2].add(position);
          unrotatedCornersAroundCenter[3] = unrotatedCornersAroundCenter[3].add(position);
          

          return unrotatedCornersAroundCenter;
      }
	
}
